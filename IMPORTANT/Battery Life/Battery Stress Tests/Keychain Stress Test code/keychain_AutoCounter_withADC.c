#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>

#include <time.h>
#include <sys/time.h>

#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/event_groups.h"

#include "esp_system.h"
#include "esp_sleep.h"
#include "esp_log.h"
#include "esp_timer.h"
#include "esp32/ulp.h"
#include "esp_err.h"

#include "esp_bt.h"
#include "esp_gap_ble_api.h"
#include "esp_gatts_api.h"
#include "esp_bt_defs.h"
#include "esp_bt_main.h"
#include "esp_gatt_common_api.h"

#include "nvs_flash.h"
#include "nvs.h"

#include "driver/gpio.h"
#include "driver/touch_pad.h"
#include "driver/adc.h"
#include "driver/rtc_io.h"
#include "driver/i2c.h"

#include "soc/sens_periph.h"
#include "soc/rtc.h"

#include "sdkconfig.h" // generated by "make menuconfig"

#include "thirukkural.c"
// #include "thirukkural_small.c"

#include "imagedata.h"
#include "epaper-29-ws.h"
#include "epaper_fonts.h"
#include "tamil_fonts2.h"
#include "bamini_12_3_21_1s.h"

#include "esp_adc_cal.h"
#define DEFAULT_VREF    2100        //Use adc2_vref_to_gpio() to obtain a better estimate
#define NO_OF_SAMPLES   64          //Multisampling

#if CONFIG_IDF_TARGET_ESP32
static esp_adc_cal_characteristics_t *adc_chars;
static const adc_channel_t channel = ADC_CHANNEL_6;     // GPIO34 if ADC1, GPIO14 if ADC2
#elif CONFIG_IDF_TARGET_ESP32S2BETA
static const adc_channel_t channel = ADC_CHANNEL_6;     // GPIO7 if ADC1, GPIO17 if ADC2
#endif 
static const adc_atten_t atten = ADC_ATTEN_DB_0;
static const adc_unit_t unit = ADC_UNIT_1;

#if CONFIG_IDF_TARGET_ESP32
static void check_efuse(void)
{
    //Check TP is burned into eFuse
    if (esp_adc_cal_check_efuse(ESP_ADC_CAL_VAL_EFUSE_TP) == ESP_OK) {
        printf("eFuse Two Point: Supported\n");
    } else {
        printf("eFuse Two Point: NOT supported\n");
    }

    //Check Vref is burned into eFuse
    if (esp_adc_cal_check_efuse(ESP_ADC_CAL_VAL_EFUSE_VREF) == ESP_OK) {
        printf("eFuse Vref: Supported\n");
    } else {
        printf("eFuse Vref: NOT supported\n");
    }
}

static void print_char_val_type(esp_adc_cal_value_t val_type)
{
    if (val_type == ESP_ADC_CAL_VAL_EFUSE_TP) {
        printf("Characterized using Two Point Value\n");
    } else if (val_type == ESP_ADC_CAL_VAL_EFUSE_VREF) {
        printf("Characterized using eFuse Vref\n");
    } else {
        printf("Characterized using Default Vref\n");
    }
}
#endif

#include "utils/string_utils.c"

// #define SDA_PIN GPIO_NUM_21
// #define SCL_PIN GPIO_NUM_22

#define STORAGE_NAMESPACE "storage"

// Pin definition of the ePaper module
#define MOSI_PIN 5
#define MISO_PIN -1
#define SCK_PIN 18
#define BUSY_PIN 32 //32 Before change GPIO one side
#define DC_PIN 27   //27 Before change GPIO one side
#define RST_PIN 23  //FOR OTHER: 16
#define CS_PIN 19

// Color inverse. 1 or 0 = set or reset a bit if set a colored pixel
#define IF_INVERT_COLOR 1

#define GATTS_TAG "POCKET_MAIN"

static const char *TAG = "ADMATIC";
static const char *TAG1 = "ePaper Example";
static const char *TAG2 = "SNTP Time";

static char *KEY_KURAL_NUMBER = "kural_number";
static char *KEY_B1_PREV = "b1_count";
static char *KEY_B2_NEXT = "b2_count";
static char *KEY_B3_FAV = "b3_count";
static char *KEY_B4_POWER = "b4_count";
static char *KEY_BLE_MODE = "ble_count";
static char *KEY_FAVORITES = "favorites";
static char *KEY_READ_OFFSET = "read_offset";

///Declare the static function
static void gatts_profile_a_event_handler(esp_gatts_cb_event_t event, esp_gatt_if_t gatts_if, esp_ble_gatts_cb_param_t *param);
static void gatts_profile_b_event_handler(esp_gatts_cb_event_t event, esp_gatt_if_t gatts_if, esp_ble_gatts_cb_param_t *param);

#define GATTS_SERVICE_UUID_TEST_A 0xFF00
#define GATTS_CHAR_UUID_TEST_A 0xFF01
#define GATTS_DESCR_UUID_TEST_A 0x3333
#define GATTS_NUM_HANDLE_TEST_A 4

#define GATTS_SERVICE_UUID_TEST_B 0xEE00
#define GATTS_CHAR_UUID_TEST_B 0xEE01
#define GATTS_DESCR_UUID_TEST_B 0x2222
#define GATTS_NUM_HANDLE_TEST_B 4

int bleblink = 0;
#define TEST_DEVICE_NAME "SMART POCKET"

#define TEST_MANUFACTURER_DATA_LEN 17

char strftime_buf[64];

static char *address;
static struct tm tm;
static time_t t;

static struct tm timeinfo = {0};

#define GATTS_DEMO_CHAR_VAL_LEN_MAX 0x40

#define PREPARE_BUF_MAX_SIZE 1024

static uint8_t char1_str[] = {0x11, 0x22, 0x33};
static esp_gatt_char_prop_t a_property = 0;
static esp_gatt_char_prop_t b_property = 0;

static esp_attr_value_t gatts_demo_char1_val = {
    .attr_max_len = GATTS_DEMO_CHAR_VAL_LEN_MAX,
    .attr_len = sizeof(char1_str),
    .attr_value = char1_str,
};

static uint8_t adv_config_done = 0;
#define adv_config_flag (1 << 0)
#define scan_rsp_config_flag (1 << 1)

static uint8_t adv_service_uuid128[32] = {
    /* LSB <--------------------------------------------------------------------------------> MSB */
    //first uuid, 16bit, [12],[13] is the value
    0xfb,
    0x34,
    0x9b,
    0x5f,
    0x80,
    0x00,
    0x00,
    0x80,
    0x00,
    0x10,
    0x00,
    0x00,
    0xEE,
    0x00,
    0x00,
    0x00,
    //second uuid, 32bit, [12], [13], [14], [15] is the value
    0xfb,
    0x34,
    0x9b,
    0x5f,
    0x80,
    0x00,
    0x00,
    0x80,
    0x00,
    0x10,
    0x00,
    0x00,
    0xFF,
    0x00,
    0x00,
    0x00,
};

// The length of adv data must be less than 31 bytes
//static uint8_t test_manufacturer[TEST_MANUFACTURER_DATA_LEN] =  {0x12, 0x23, 0x45, 0x56};
//adv data
static esp_ble_adv_data_t adv_data = {
    .set_scan_rsp = false,
    .include_name = true,
    .include_txpower = false,
    .min_interval = 0x0006, //slave connection min interval, Time = min_interval * 1.25 msec
    .max_interval = 0x0010, //slave connection max interval, Time = max_interval * 1.25 msec
    .appearance = 0x00,
    .manufacturer_len = 0,       //TEST_MANUFACTURER_DATA_LEN,
    .p_manufacturer_data = NULL, //&test_manufacturer[0],
    .service_data_len = 0,
    .p_service_data = NULL,
    .service_uuid_len = sizeof(adv_service_uuid128),
    .p_service_uuid = adv_service_uuid128,
    .flag = (ESP_BLE_ADV_FLAG_GEN_DISC | ESP_BLE_ADV_FLAG_BREDR_NOT_SPT),
};
// scan response data
static esp_ble_adv_data_t scan_rsp_data = {
    .set_scan_rsp = true,
    .include_name = true,
    .include_txpower = true,
    //.min_interval = 0x0006,
    //.max_interval = 0x0010,
    .appearance = 0x00,
    .manufacturer_len = 0,       //TEST_MANUFACTURER_DATA_LEN,
    .p_manufacturer_data = NULL, //&test_manufacturer[0],
    .service_data_len = 0,
    .p_service_data = NULL,
    .service_uuid_len = sizeof(adv_service_uuid128),
    .p_service_uuid = adv_service_uuid128,
    .flag = (ESP_BLE_ADV_FLAG_GEN_DISC | ESP_BLE_ADV_FLAG_BREDR_NOT_SPT),
};

static esp_ble_adv_params_t adv_params = {
    .adv_int_min = 0x20,
    .adv_int_max = 0x40,
    .adv_type = ADV_TYPE_IND,
    .own_addr_type = BLE_ADDR_TYPE_PUBLIC,
    //.peer_addr            =
    //.peer_addr_type       =
    .channel_map = ADV_CHNL_ALL,
    .adv_filter_policy = ADV_FILTER_ALLOW_SCAN_ANY_CON_ANY,
};

#define PROFILE_NUM 2
#define PROFILE_A_APP_ID 0
#define PROFILE_B_APP_ID 1

struct gatts_profile_inst
{
    esp_gatts_cb_t gatts_cb;
    uint16_t gatts_if;
    uint16_t app_id;
    uint16_t conn_id;
    uint16_t service_handle;
    esp_gatt_srvc_id_t service_id;
    uint16_t char_handle;
    esp_bt_uuid_t char_uuid;
    esp_gatt_perm_t perm;
    esp_gatt_char_prop_t property;
    uint16_t descr_handle;
    esp_bt_uuid_t descr_uuid;
};

/* One gatt-based profile one app_id and one gatts_if, this array will store the gatts_if returned by ESP_GATTS_REG_EVT */
static struct gatts_profile_inst gl_profile_tab[PROFILE_NUM] = {
    [PROFILE_A_APP_ID] = {
        .gatts_cb = gatts_profile_a_event_handler,
        .gatts_if = ESP_GATT_IF_NONE, /* Not get the gatt_if, so initial is ESP_GATT_IF_NONE */
    },
    [PROFILE_B_APP_ID] = {
        .gatts_cb = gatts_profile_b_event_handler, /* This demo does not implement, similar as profile A */
        .gatts_if = ESP_GATT_IF_NONE,              /* Not get the gatt_if, so initial is ESP_GATT_IF_NONE */
    },
};

typedef struct
{
    uint8_t *prepare_buf;
    int prepare_len;
} prepare_type_env_t;

int32_t get_i32_in_nvs(char *key)
{
    nvs_handle_t my_handle;
    esp_err_t err = nvs_open(STORAGE_NAMESPACE, NVS_READWRITE, &my_handle);
    if (err != ESP_OK)
    {
        ESP_LOGE(TAG, "%s", esp_err_to_name(err));
        return err;
    }

    int32_t value = 0;
    err = nvs_get_i32(my_handle, key, &value);
    if (err != ESP_OK && err != ESP_ERR_NVS_NOT_FOUND)
    {
        ESP_LOGE(TAG, "%s", esp_err_to_name(err));
        return err;
    }

    nvs_close(my_handle);

    return value;
}

esp_err_t set_i32_in_nvs(char *key, int32_t value)
{
    nvs_handle_t my_handle;
    esp_err_t err = nvs_open(STORAGE_NAMESPACE, NVS_READWRITE, &my_handle);
    if (err != ESP_OK)
    {
        ESP_LOGE(TAG, "%s", esp_err_to_name(err));
        return err;
    }

    get_i32_in_nvs(key);
    err = nvs_set_i32(my_handle, key, value);
    if (err != ESP_OK)
    {
        ESP_LOGE(TAG, "%s", esp_err_to_name(err));
        return err;
    }

    err = nvs_commit(my_handle);
    if (err != ESP_OK)
    {
        ESP_LOGE(TAG, "%s", esp_err_to_name(err));
        return err;
    }

    nvs_close(my_handle);

    return ESP_OK;
}

static prepare_type_env_t a_prepare_write_env;
static prepare_type_env_t b_prepare_write_env;

void example_write_event_env(esp_gatt_if_t gatts_if, prepare_type_env_t *prepare_write_env, esp_ble_gatts_cb_param_t *param);
void example_exec_write_event_env(prepare_type_env_t *prepare_write_env, esp_ble_gatts_cb_param_t *param);

static RTC_DATA_ATTR struct timeval sleep_enter_time;

char n[100];
char p[100];
char o[100];
char tempfil[100];
char tempfil2[10];
char q[10];
char r[100];
char s[100];


void e_paper_task(const void *bar_no)
{   
    int percent3=0;
    int percent2=(int)bar_no;
    if(percent2>101){
        percent3=percent2-1000;
    } 
    if(percent2<101){
        percent3=percent2;
    }
    printf("\n%d%% of Battery left\n", percent3);
    sprintf(q, "%d%%", percent3);
    

    // THIS IS THE CODE FOR PRINTING TIME ON SCREEN as Date/Time 24hr/Time 12hr
    strftime(strftime_buf, sizeof(strftime_buf), "%c", &timeinfo);
    for(int i=0; i<5; i++){
        n[i]=strftime_buf[i+11];
    }
    int pm_num= atoi (n);
    if(pm_num==24){
        sprintf(p, "%d", 12);
    } else if (pm_num >0 && pm_num<13){
        sprintf(p, "%d", pm_num);
    } else if (pm_num > 12 && pm_num < 24){
        sprintf(p, "%d", (pm_num-12));
    }
    for(int i=0; i<3; i++){
        tempfil[i]=strftime_buf[i+13];
    }
    sprintf(p + strlen(p), "%s", tempfil);
    if(pm_num==24){
        sprintf(p + strlen(p), "%s", " am");
    } else if (pm_num >0 && pm_num<13){
        sprintf(p + strlen(p), "%s", " am");
    } else if (pm_num > 12 && pm_num < 24){
        sprintf(p + strlen(p), "%s", " pm");
    }
    for(int i=0; i<7; i++){
        o[i]=strftime_buf[i+4];
    }
    for(int i=0; i<4; i++){
        tempfil2[i]=strftime_buf[i+20];
    }
    sprintf(o + strlen(o), "%s", tempfil2);
    


    epaper_handle_t device = NULL;

    epaper_conf_t epaper_conf = {
        .busy_pin = BUSY_PIN,   // pin 32           CLK pin 18
                    //RST          pin 23           DIN pin 5
        .cs_pin = CS_PIN,       // pin 19           GND pin
        .dc_pin = DC_PIN,       // pin 27           VCC pin
        .miso_pin = MISO_PIN,
        .mosi_pin = MOSI_PIN,
        .reset_pin = RST_PIN,
        .sck_pin = SCK_PIN,

        .rst_active_level = 0,
        .busy_active_level = 1,

        .dc_lev_data = 1,
        .dc_lev_cmd = 0,

        .clk_freq_hz = 20 * 1000 * 1000,
        .spi_host = HSPI_HOST,

        .width = EPD_WIDTH,
        .height = EPD_HEIGHT,
        .color_inv = 1,
    };

    nvs_handle_t my_handle;
    esp_err_t err;
    err = nvs_open(STORAGE_NAMESPACE, NVS_READWRITE, &my_handle);

    int32_t current_kural_number = get_i32_in_nvs(KEY_KURAL_NUMBER);
    int find_fav = 0;
    size_t fav_size = 0;
    int32_t restart_counter = 0; // value will default to 0, if not set yet in NVS                          //  FOR BATTERY TESTING
    err = nvs_get_i32(my_handle, "restart_conter", &restart_counter);                                       //  FOR BATTERY TESTING
    sprintf(r, "%d", restart_counter);                                                                      //  FOR BATTERY TESTING
    int32_t adc_nvs = 0; // value will default to 0, if not set yet in NVS                          //  FOR BATTERY TESTING
    err = nvs_get_i32(my_handle, "adc_nnvs", &adc_nvs);                                       //  FOR BATTERY TESTING
    sprintf(s, "%d", adc_nvs);                                                                      //  FOR BATTERY TESTING
    // obtain required memory space to store blob being read from NVS
    err = nvs_get_blob(my_handle, KEY_FAVORITES, NULL, &fav_size);
    if (err != ESP_OK && err != ESP_ERR_NVS_NOT_FOUND)
        return;
    printf("Favourite Msgs..=");
    if (fav_size == 0)
    {
        printf(" Nothing saved yet!\n");
    }
    else
    {
        uint32_t *fav_id = malloc(fav_size);
        err = nvs_get_blob(my_handle, KEY_FAVORITES, fav_id, &fav_size);
        if (err != ESP_OK)
        {
            free(fav_id);
            return;
        }
        for (int i = 0; i < fav_size / sizeof(uint32_t); i++)
        {
            printf(" %d", fav_id[i]);
            if (current_kural_number == fav_id[i])
            {
                find_fav = 1;
                break;
            }
        }
        free(fav_id);
    }
    nvs_close(my_handle);
    vTaskDelay(50 / portTICK_PERIOD_MS);
    int barcount=0;
    if(100>= percent2 && percent2>=76){
            barcount=4;
        } else if (75>=percent2 && percent2>=51){
            barcount=3;
        } else if (50>=percent2 && percent2>=26){
            barcount=2;
        } else if (25>=percent2 && percent2>=1) {
            barcount=1;
        }
    if(1100>= percent2 && percent2>=1076){
            barcount=4;
        } else if (1075>=percent2 && percent2>=1051){
            barcount=3;
        } else if (1050>=percent2 && percent2>=1026){
            barcount=2;
        } else if (1025>=percent2 && percent2>=1001) {
            barcount=1;
        }

    ESP_LOGI(TAG1, "Before ePaper driver init, heap: %d", esp_get_free_heap_size());
    device = iot_epaper_create(NULL, &epaper_conf);
    iot_epaper_set_rotate(device, E_PAPER_ROTATE_90);
    iot_epaper_clean_paint(device, UNCOLORED);

    int printer = current_kural_number - 1;
    char *a = strNameList[printer][4];
    char *b = strNameList[printer][0];
    char *c = strNameList[printer][1];
    char *d = strNameList[printer][2];
    char *e = strNameList[printer][5];
    char *f = strNameList[printer][3];
    char *g = strNameList[printer][6];
    char *h = strNameList[printer][7];
    char *i = strNameList[printer][8];
    char *j = strNameList[printer][9];
    char *k = strNameList[printer][10];
    char *l = strNameList[printer][11];
    char m[10];
    if (barcount==0){
        sprintf(m, "%s", "Bat Err");
    } else if (barcount==4 || barcount==40){
        sprintf(m, "%s", "||||");
    } else if (barcount==3 || barcount==30){
        sprintf(m, "%s", "-|||");
    } else if (barcount==2 || barcount==20){    
        sprintf(m, "%s", "--||");
    } else {
        sprintf(m, "%s", "---|");
    }
     
    iot_epaper_draw_string(device, 163, 1, a, &epaper_font_12, COLORED); 
    iot_epaper_draw_string(device, 135, 1, f, &epaper_font_12, COLORED);
    iot_epaper_draw_string(device, 5, 0, b, &epaper_font_16, COLORED);
    if (find_fav == 1)
    {
        iot_epaper_draw_string(device, 50, 0, "Fav", &epaper_font_12, COLORED);
    }
    else
    {
        iot_epaper_draw_string(device, 50, 0, "Not Fav", &epaper_font_12, COLORED);
    } 
    // iot_epaper_draw_stringtamil(device, 8, 25, c, &epaper_font_12baminitamil, COLORED); // c here
    // iot_epaper_draw_stringtamil(device, 8, 35,d, &epaper_font_12baminitamil, COLORED);              // d here
    iot_epaper_draw_stringtamil(device, 2, 16, c, &epaper_font_12baminitamil, COLORED); // c here
    iot_epaper_draw_stringtamil(device, 2, 34,d, &epaper_font_12baminitamil, COLORED);              // d here
    iot_epaper_draw_rectangle(device, 1, 14, 295, 51, COLORED);
    iot_epaper_draw_string(device, 8, 53, e, &epaper_font_12, COLORED);
    iot_epaper_draw_string(device, 8, 63, g, &epaper_font_12, COLORED);
    iot_epaper_draw_string(device, 8, 73, h, &epaper_font_12, COLORED);
    iot_epaper_draw_string(device, 8, 83, i, &epaper_font_12, COLORED);
    iot_epaper_draw_string(device, 8, 93, j, &epaper_font_12, COLORED);
    iot_epaper_draw_string(device, 8, 103, k, &epaper_font_12, COLORED);
    iot_epaper_draw_string(device, 8, 113, l, &epaper_font_12, COLORED);
    iot_epaper_draw_string(device, 265, 93, m, &epaper_font_12, COLORED);
    iot_epaper_draw_string(device, 265, 103, q, &epaper_font_12, COLORED);
    iot_epaper_draw_string(device, 255, 113, r, &epaper_font_12, COLORED);
    iot_epaper_draw_string(device, 255, 83, s, &epaper_font_12, COLORED);
    // iot_epaper_draw_image(device, 3, 20, current_kural_number, &epaper_font_30, COLORED);
    // iot_epaper_draw_rectangle(device, 3, 20, 293, 50, COLORED);
    // iot_epaper_draw_char(device, 225, 113, "à¯µ", &myfont, COLORED);
    if(percent2<101 && percent2>0){
        iot_epaper_draw_string(device, 240, 63, n, &epaper_font_12, COLORED);
        iot_epaper_draw_string(device, 220, 53, o, &epaper_font_12, COLORED);
        iot_epaper_draw_string(device, 240, 73, p, &epaper_font_12, COLORED);
    }
    iot_epaper_display_frame(device, NULL); // display internal frame buffer
    iot_epaper_delete(device, true);
    vTaskDelay(1500 / portTICK_PERIOD_MS);
    vTaskDelete(NULL);
}

void e_paper_taskpartial(void *pvParameter)
{
    epaper_handle_t device1 = NULL;

    epaper_conf_t epaper_conf1 = {
        .busy_pin = BUSY_PIN,
        .cs_pin = CS_PIN,
        .dc_pin = DC_PIN,
        .miso_pin = MISO_PIN,
        .mosi_pin = MOSI_PIN,
        .reset_pin = RST_PIN,
        .sck_pin = SCK_PIN,

        .rst_active_level = 0,
        .busy_active_level = 1,

        .dc_lev_data = 1,
        .dc_lev_cmd = 0,

        .clk_freq_hz = 20 * 1000 * 1000,
        .spi_host = HSPI_HOST,

        .width = EPD_WIDTHIMAGE,
        .height = EPD_HEIGHTIMAGE,
        .color_inv = 1,
    };

        ESP_LOGI(TAG, "Before ePaper driver init, heap: %d", esp_get_free_heap_size());
        device1 = iot_epaper_create1(NULL, &epaper_conf1);
        iot_epaper_set_rotate(device1, E_PAPER_ROTATE_90);
        // ESP_LOGI(TAG, "e-Paper Display Espressif logo");
        iot_epaper_clean_paint(device1, UNCOLORED);
        // iot_epaper_display_framepartial(device1, IMAGE_DATA); // display IMAGE_DATA
        iot_epaper_draw_string(device1, 8, 113,"BY ADMATIC SOLUTIONS", &epaper_font_12, COLORED);
        iot_epaper_display_framepartial(device1, NULL); // display internal frame buffer

        // vTaskDelay(1000 / portTICK_PERIOD_MS);
        // iot_epaper_draw_rectangle(device, 10, 20, 220, 50, COLORED);
        // iot_epaper_display_frame(device, NULL); // display internal frame buffer

        iot_epaper_delete(device1, true);
        // ESP_LOGI(TAG, "EPD Display update count: %d", cnt++);
        ESP_LOGI(TAG, "After ePaper driver delete, heap: %d", esp_get_free_heap_size());
        vTaskDelay(1500 / portTICK_PERIOD_MS);

        vTaskDelete(NULL);
}

esp_err_t save_restart_counter(void)
{
    nvs_handle_t my_handle;
    esp_err_t err;

    // Open
    err = nvs_open(STORAGE_NAMESPACE, NVS_READWRITE, &my_handle);
    if (err != ESP_OK) return err;

    // Read
    int32_t restart_counter = 0; // value will default to 0, if not set yet in NVS
    err = nvs_get_i32(my_handle, "restart_conter", &restart_counter);
    if (err != ESP_OK && err != ESP_ERR_NVS_NOT_FOUND) return err;

    // Write
    restart_counter++;
    err = nvs_set_i32(my_handle, "restart_conter", restart_counter);
    if (err != ESP_OK) return err;

    // Commit written value.
    // After setting any values, nvs_commit() must be called to ensure changes are written
    // to flash storage. Implementations may write to storage at other times,
    // but this is not guaranteed.
    err = nvs_commit(my_handle);
    if (err != ESP_OK) return err;

    // Close
    nvs_close(my_handle);
    return ESP_OK;
}

esp_err_t save_adc(int adc_valf)
{
    nvs_handle_t my_handle;
    esp_err_t err;

    // Open
    err = nvs_open(STORAGE_NAMESPACE, NVS_READWRITE, &my_handle);
    if (err != ESP_OK) return err;

    // Read
    int32_t adc_nvs = 0; // value will default to 0, if not set yet in NVS
    err = nvs_get_i32(my_handle, "adc_nnvs", &adc_nvs);
    if (err != ESP_OK && err != ESP_ERR_NVS_NOT_FOUND) return err;

    // Write
    adc_nvs=adc_valf;
    err = nvs_set_i32(my_handle, "adc_nnvs", adc_nvs);
    if (err != ESP_OK) return err;

    // Commit written value.
    // After setting any values, nvs_commit() must be called to ensure changes are written
    // to flash storage. Implementations may write to storage at other times,
    // but this is not guaranteed.
    err = nvs_commit(my_handle);
    if (err != ESP_OK) return err;

    // Close
    nvs_close(my_handle);
    return ESP_OK;
}

esp_err_t save_button_press1(void)
{
    nvs_handle_t my_handle;
    esp_err_t err;

    time(&t);
    localtime_r(&t, &timeinfo);
    strftime(strftime_buf, sizeof(strftime_buf), "%c", &timeinfo);

    err = nvs_open(STORAGE_NAMESPACE, NVS_READWRITE, &my_handle);
    if (err != ESP_OK)
        return err;

    int32_t button_press1 = get_i32_in_nvs(KEY_B1_PREV);
    int32_t button_press2 = get_i32_in_nvs(KEY_B2_NEXT);

    button_press1++;
    set_i32_in_nvs(KEY_B1_PREV, button_press1);

    int totalButtonPress = button_press1 + button_press2;
    char totalchar[500];
    sprintf(totalchar, "%d", totalButtonPress);

    int32_t current_kural_number = get_i32_in_nvs(KEY_KURAL_NUMBER);
    current_kural_number--;
    if (current_kural_number < 1)
    {
        current_kural_number = 1330;
    }
    set_i32_in_nvs(KEY_KURAL_NUMBER, current_kural_number);
    char *kural_number_string = int_to_4_char_string(current_kural_number);

    char buffer[100];
    sprintf(buffer, "%s %s", kural_number_string, strftime_buf);
    err = nvs_set_str(my_handle, totalchar, buffer);
    if (err != ESP_OK)
        return err;

    err = nvs_commit(my_handle);
    if (err != ESP_OK)
        return err;

    nvs_close(my_handle);
    return ESP_OK;
}

esp_err_t save_button_press2(void)
{
    nvs_handle_t my_handle;
    esp_err_t err;

    time(&t);
    localtime_r(&t, &timeinfo);
    strftime(strftime_buf, sizeof(strftime_buf), "%c", &timeinfo);

    err = nvs_open(STORAGE_NAMESPACE, NVS_READWRITE, &my_handle);
    if (err != ESP_OK)
        return err;

    int32_t button_press1 = get_i32_in_nvs(KEY_B1_PREV);
    int32_t button_press2 = get_i32_in_nvs(KEY_B2_NEXT);

    button_press2++;
    set_i32_in_nvs(KEY_B2_NEXT, button_press2);

    int totalButtonPress = button_press1 + button_press2;
    char totalchar[500];
    sprintf(totalchar, "%d", totalButtonPress);

    int32_t current_kural_number = get_i32_in_nvs(KEY_KURAL_NUMBER);
    current_kural_number++;
    if (current_kural_number > 1330)
    {
        current_kural_number = 1;
    }
    set_i32_in_nvs(KEY_KURAL_NUMBER, current_kural_number);
    char *kural_number_string = int_to_4_char_string(current_kural_number);

    char buffer[100];
    sprintf(buffer, "%s %s", kural_number_string, strftime_buf);
    err = nvs_set_str(my_handle, totalchar, buffer);
    if (err != ESP_OK)
        return err;

    err = nvs_commit(my_handle);
    if (err != ESP_OK)
        return err;

    nvs_close(my_handle);
    return ESP_OK;
}

esp_err_t increment_nvs_value(char *key)
{
    int32_t value = get_i32_in_nvs(key);
    value++;
    set_i32_in_nvs(key, value);

    return ESP_OK;
}

int save_fav(void)
{
    nvs_handle_t my_handle;
    esp_err_t err;

    err = nvs_open(STORAGE_NAMESPACE, NVS_READWRITE, &my_handle);
    if (err != ESP_OK)
        return err;

    int32_t button_press3 = get_i32_in_nvs(KEY_B3_FAV);

    button_press3++;
    set_i32_in_nvs(KEY_B3_FAV, button_press3);

    int32_t current_kural_number = get_i32_in_nvs(KEY_KURAL_NUMBER);

    // Read the size of memory space required for blob
    size_t fav_size = 0;
    err = nvs_get_blob(my_handle, KEY_FAVORITES, NULL, &fav_size);
    if (err != ESP_OK && err != ESP_ERR_NVS_NOT_FOUND)
        return err;

    // Read previously saved blob if available
    uint32_t *fav_id = malloc(fav_size + sizeof(uint32_t));
    if (fav_size > 0)
    {
        err = nvs_get_blob(my_handle, KEY_FAVORITES, fav_id, &fav_size);
        if (err != ESP_OK)
        {
            free(fav_id);
            return err;
        }
    }
    int flag_skip = 0;
    if (fav_size > 0)
    {
        for (int i = 0; i <= (fav_size / sizeof(uint32_t)); i++)
        {
            if (fav_size > i)
            {
                if (fav_id[i] == current_kural_number)
                {
                    for (int okrun = i; okrun < ((fav_size / sizeof(uint32_t)) - 1); okrun++)
                    {
                        fav_id[okrun] = fav_id[okrun + 1];
                    }
                    fav_size -= sizeof(uint32_t);
                    flag_skip = 1;

                    err = nvs_set_blob(my_handle, KEY_FAVORITES, fav_id, fav_size);
                    free(fav_id);
                    break;
                }
            }
        }
    }
    if (flag_skip == 0)
    {
        fav_size += sizeof(uint32_t);
        fav_id[fav_size / sizeof(uint32_t) - 1] = current_kural_number;

        err = nvs_set_blob(my_handle, KEY_FAVORITES, fav_id, fav_size);
        free(fav_id);

        if (err != ESP_OK)
            return err;
    }
    nvs_close(my_handle);

    return flag_skip;
}

// void i2c_master_init()
// {
//     i2c_config_t i2c_config = {
//         .mode = I2C_MODE_MASTER,
//         .sda_io_num = SDA_PIN,
//         .scl_io_num = SCL_PIN,
//         .sda_pullup_en = GPIO_PULLUP_ENABLE,
//         .scl_pullup_en = GPIO_PULLUP_ENABLE,
//         .master.clk_speed = 1000000};
//     i2c_param_config(I2C_NUM_0, &i2c_config);
//     i2c_driver_install(I2C_NUM_0, I2C_MODE_MASTER, 0, 0, 0);
// }

esp_err_t print_what_saved(void)
{
    nvs_handle_t my_handle;
    esp_err_t err = nvs_open(STORAGE_NAMESPACE, NVS_READWRITE, &my_handle);
    if (err != ESP_OK)
        return err;

    strftime(strftime_buf, sizeof(strftime_buf), "%c", &timeinfo);
    ESP_LOGI(TAG2, "The current date/time in India is: %s", strftime_buf);

    int32_t current_kural_number = get_i32_in_nvs(KEY_KURAL_NUMBER);
    int32_t button_press1 = get_i32_in_nvs(KEY_B1_PREV);
    int32_t button_press2 = get_i32_in_nvs(KEY_B2_NEXT);
    int32_t button_press3 = get_i32_in_nvs(KEY_B3_FAV);
    int32_t button_press4 = get_i32_in_nvs(KEY_B4_POWER);
    int32_t button_press5 = get_i32_in_nvs(KEY_BLE_MODE);

    printf("Current Kural...= %d\n", current_kural_number);
    printf("Back Button.....= %d\n", button_press1);
    printf("Front Button....= %d\n", button_press2);
    printf("FavButton Toggle= %d\n", button_press3);
    printf("Deep Sleep/Wakes= %d\n", button_press4);
    printf("BT Mode Used....= %d\n", button_press5);

    size_t fav_size = 0;
    // obtain required memory space to store blob being read from NVS
    err = nvs_get_blob(my_handle, KEY_FAVORITES, NULL, &fav_size);
    if (err != ESP_OK && err != ESP_ERR_NVS_NOT_FOUND)
        return err;
    printf("Favourite Msgs..=");
    if (fav_size == 0)
    {
        printf(" Nothing saved yet!\n");
    }
    else
    {
        uint32_t *fav_id = malloc(fav_size);
        err = nvs_get_blob(my_handle, KEY_FAVORITES, fav_id, &fav_size);
        if (err != ESP_OK)
        {
            free(fav_id);
            return err;
        }
        for (int i = 0; i < fav_size / sizeof(uint32_t); i++)
        {
            printf(" %d", fav_id[i]);
        }
        printf("\nTotal Favourites= %d", fav_size / 4);
        free(fav_id);
    }

    int totalButtoonPress = button_press1 + button_press2;
    for (int i = 1; i <= totalButtoonPress; i++)
    {
        char totalchar[500];
        sprintf(totalchar, "%d", i);
        char read_log[1000];
        size_t strlongth = malloc(1000);
        err = nvs_get_str(my_handle, totalchar, read_log, &strlongth);
        if (err != ESP_OK && err != ESP_ERR_NVS_NOT_FOUND)
            return err;
        printf("\nKural No. & its Timestamp: %s", read_log);
    }

    nvs_close(my_handle);
    return ESP_OK;
}

static void gap_event_handler(esp_gap_ble_cb_event_t event, esp_ble_gap_cb_param_t *param)
{
    switch (event)
    {
    case ESP_GAP_BLE_ADV_DATA_SET_COMPLETE_EVT:
        adv_config_done &= (~adv_config_flag);
        if (adv_config_done == 0)
        {
            esp_ble_gap_start_advertising(&adv_params);
        }
        break;
    case ESP_GAP_BLE_SCAN_RSP_DATA_SET_COMPLETE_EVT:
        adv_config_done &= (~scan_rsp_config_flag);
        if (adv_config_done == 0)
        {
            esp_ble_gap_start_advertising(&adv_params);
        }
        break;

    case ESP_GAP_BLE_ADV_START_COMPLETE_EVT:
        //advertising start complete event to indicate advertising start successfully or failed
        if (param->adv_start_cmpl.status != ESP_BT_STATUS_SUCCESS)
        {
            ESP_LOGE(GATTS_TAG, "Advertising start failed\n");
        }
        break;
    case ESP_GAP_BLE_ADV_STOP_COMPLETE_EVT:
        if (param->adv_stop_cmpl.status != ESP_BT_STATUS_SUCCESS)
        {
            ESP_LOGE(GATTS_TAG, "Advertising stop failed\n");
        }
        else
        {
            ESP_LOGI(GATTS_TAG, "Stop adv successfully\n");
        }
        break;
    case ESP_GAP_BLE_UPDATE_CONN_PARAMS_EVT:
        ESP_LOGI(GATTS_TAG, "update connection params status = %d, min_int = %d, max_int = %d,conn_int = %d,latency = %d, timeout = %d",
                 param->update_conn_params.status,
                 param->update_conn_params.min_int,
                 param->update_conn_params.max_int,
                 param->update_conn_params.conn_int,
                 param->update_conn_params.latency,
                 param->update_conn_params.timeout);
        break;
    default:
        break;
    }
}

void example_write_event_env(esp_gatt_if_t gatts_if, prepare_type_env_t *prepare_write_env, esp_ble_gatts_cb_param_t *param)
{
    esp_gatt_status_t status = ESP_GATT_OK;
    if (param->write.need_rsp)
    {
        if (param->write.is_prep)
        {
            if (prepare_write_env->prepare_buf == NULL)
            {
                prepare_write_env->prepare_buf = (uint8_t *)malloc(PREPARE_BUF_MAX_SIZE * sizeof(uint8_t));
                prepare_write_env->prepare_len = 0;
                if (prepare_write_env->prepare_buf == NULL)
                {
                    ESP_LOGE(GATTS_TAG, "Gatt_server prep no mem\n");
                    status = ESP_GATT_NO_RESOURCES;
                }
            }
            else
            {
                if (param->write.offset > PREPARE_BUF_MAX_SIZE)
                {
                    status = ESP_GATT_INVALID_OFFSET;
                }
                else if ((param->write.offset + param->write.len) > PREPARE_BUF_MAX_SIZE)
                {
                    status = ESP_GATT_INVALID_ATTR_LEN;
                }
            }

            esp_gatt_rsp_t *gatt_rsp = (esp_gatt_rsp_t *)malloc(sizeof(esp_gatt_rsp_t));
            gatt_rsp->attr_value.len = param->write.len;
            gatt_rsp->attr_value.handle = param->write.handle;
            gatt_rsp->attr_value.offset = param->write.offset;
            gatt_rsp->attr_value.auth_req = ESP_GATT_AUTH_REQ_NONE;
            memcpy(gatt_rsp->attr_value.value, param->write.value, param->write.len);
            esp_err_t response_err = esp_ble_gatts_send_response(gatts_if, param->write.conn_id, param->write.trans_id, status, gatt_rsp);
            if (response_err != ESP_OK)
            {
                ESP_LOGE(GATTS_TAG, "Send response error\n");
            }
            free(gatt_rsp);
            if (status != ESP_GATT_OK)
            {
                return;
            }
            memcpy(prepare_write_env->prepare_buf + param->write.offset,
                   param->write.value,
                   param->write.len);
            prepare_write_env->prepare_len += param->write.len;
        }
        else
        {
            esp_ble_gatts_send_response(gatts_if, param->write.conn_id, param->write.trans_id, status, NULL);
        }
    }
}

void example_exec_write_event_env(prepare_type_env_t *prepare_write_env, esp_ble_gatts_cb_param_t *param)
{
    if (param->exec_write.exec_write_flag == ESP_GATT_PREP_WRITE_EXEC)
    {
        esp_log_buffer_hex(GATTS_TAG, prepare_write_env->prepare_buf, prepare_write_env->prepare_len);
    }
    else
    {
        ESP_LOGI(GATTS_TAG, "ESP_GATT_PREP_WRITE_CANCEL");
    }
    if (prepare_write_env->prepare_buf)
    {
        free(prepare_write_env->prepare_buf);
        prepare_write_env->prepare_buf = NULL;
    }
    prepare_write_env->prepare_len = 0;
}

static void gatts_profile_a_event_handler(esp_gatts_cb_event_t event, esp_gatt_if_t gatts_if, esp_ble_gatts_cb_param_t *param)
{
    switch (event)
    {
    case ESP_GATTS_REG_EVT:
        ESP_LOGI(GATTS_TAG, "REGISTER_APP_EVT, status %d, app_id %d\n", param->reg.status, param->reg.app_id);
        gl_profile_tab[PROFILE_A_APP_ID].service_id.is_primary = true;
        gl_profile_tab[PROFILE_A_APP_ID].service_id.id.inst_id = 0x00;
        gl_profile_tab[PROFILE_A_APP_ID].service_id.id.uuid.len = ESP_UUID_LEN_16;
        gl_profile_tab[PROFILE_A_APP_ID].service_id.id.uuid.uuid.uuid16 = GATTS_SERVICE_UUID_TEST_A;

        esp_err_t set_dev_name_ret = esp_ble_gap_set_device_name(TEST_DEVICE_NAME);
        if (set_dev_name_ret)
        {
            ESP_LOGE(GATTS_TAG, "set device name failed, error code = %x", set_dev_name_ret);
        }

        //config adv data
        esp_err_t ret = esp_ble_gap_config_adv_data(&adv_data);
        if (ret)
        {
            ESP_LOGE(GATTS_TAG, "config adv data failed, error code = %x", ret);
        }
        adv_config_done |= adv_config_flag;
        //config scan response data
        ret = esp_ble_gap_config_adv_data(&scan_rsp_data);
        if (ret)
        {
            ESP_LOGE(GATTS_TAG, "config scan response data failed, error code = %x", ret);
        }
        adv_config_done |= scan_rsp_config_flag;

        esp_ble_gatts_create_service(gatts_if, &gl_profile_tab[PROFILE_A_APP_ID].service_id, GATTS_NUM_HANDLE_TEST_A);
        break;
    case ESP_GATTS_READ_EVT:
    {
        nvs_handle_t my_handle;
        esp_err_t err;

        err = nvs_open(STORAGE_NAMESPACE, NVS_READWRITE, &my_handle);
        if (err != ESP_OK)
            return;

        size_t fav_size = 0;
        // obtain required memory space to store blob being read from NVS
        err = nvs_get_blob(my_handle, KEY_FAVORITES, NULL, &fav_size);
        if (err != ESP_OK && err != ESP_ERR_NVS_NOT_FOUND)
            return;

        ESP_LOGI(GATTS_TAG, "GATT_READ_EVT, conn_id %d, trans_id %d, handle %d\n", param->read.conn_id, param->read.trans_id, param->read.handle);
        esp_gatt_rsp_t rsp;
        memset(&rsp, 0, sizeof(esp_gatt_rsp_t));
        rsp.attr_value.handle = param->read.handle;
        if (fav_size == 0)
        {
            rsp.attr_value.len = 1;
            rsp.attr_value.value[0] = 0;
        }
        else
        {
            uint32_t *fav_id = malloc(fav_size);
            err = nvs_get_blob(my_handle, KEY_FAVORITES, fav_id, &fav_size);
            if (err != ESP_OK)
            {
                free(fav_id);
                return;
            }

            int skipfav = 0;
            for (int i = 0; i < fav_size / sizeof(uint32_t); i++)
            {
                char *blank = int_to_4_char_string(fav_id[i]);
                for (int j = 0; j < 4; j++)
                {
                    rsp.attr_value.value[skipfav + j] = blank[j];
                }
                rsp.attr_value.value[skipfav + 4] = ';';
                skipfav = skipfav + 5;
            }
            rsp.attr_value.len = skipfav;

            free(fav_id);
        }

        esp_ble_gatts_send_response(gatts_if, param->read.conn_id, param->read.trans_id,
                                    ESP_GATT_OK, &rsp);
        nvs_close(my_handle);
        break;
    }
    case ESP_GATTS_WRITE_EVT:
    {
        ESP_LOGI(GATTS_TAG, "GATT_WRITE_EVT, conn_id %d, trans_id %d, handle %d", param->write.conn_id, param->write.trans_id, param->write.handle);
        if (!param->write.is_prep)
        {
            ESP_LOGI(GATTS_TAG, "GATT_WRITE_EVT, value len %d, value :", param->write.len);
            esp_log_buffer_hex(GATTS_TAG, param->write.value, param->write.len);

            printf("%d\n", param->write.value[0]);

            char *h2s = hex_to_string(param->write.value, param->write.len, 1);
            switch (param->write.value[0])
            {
            case 48:
                set_i32_in_nvs(KEY_READ_OFFSET, atoi(h2s));
                break;
            case 49:
                set_i32_in_nvs(KEY_KURAL_NUMBER, atoi(h2s));
                xTaskCreate(&e_paper_task, "epaper_task", 4 * 1024, (void *)0, 5, NULL);
                break;
            case 50:
                printf("save_button_press1\n");
                save_button_press1();
                break;
            case 51:
                printf("save_button_press2\n");
                save_button_press2();
                break;
            case 52:
                printf("save_fav\n");
                save_fav();
                break;

            case 53:
                print_what_saved();
                break;

            case 54:
                printf("save_power_button_press\n");
                increment_nvs_value(KEY_B4_POWER);
                break;
            case 55:
                printf("save_button_press5\n");
                increment_nvs_value(KEY_BLE_MODE);
                break;

            default:
                break;
            }

            if (gl_profile_tab[PROFILE_A_APP_ID].descr_handle == param->write.handle && param->write.len == 2)
            {
                uint16_t descr_value = param->write.value[1] << 8 | param->write.value[0];
                if (descr_value == 0x0001)
                {
                    if (a_property & ESP_GATT_CHAR_PROP_BIT_NOTIFY)
                    {
                        ESP_LOGI(GATTS_TAG, "notify enable");
                        uint8_t notify_data[15];
                        for (int i = 0; i < sizeof(notify_data); ++i)
                        {
                            notify_data[i] = i % 0xff;
                        }
                        //the size of notify_data[] need less than MTU size
                        esp_ble_gatts_send_indicate(gatts_if, param->write.conn_id, gl_profile_tab[PROFILE_A_APP_ID].char_handle,
                                                    sizeof(notify_data), notify_data, false);
                    }
                }
                else if (descr_value == 0x0002)
                {
                    if (a_property & ESP_GATT_CHAR_PROP_BIT_INDICATE)
                    {
                        ESP_LOGI(GATTS_TAG, "indicate enable");
                        uint8_t indicate_data[15];
                        for (int i = 0; i < sizeof(indicate_data); ++i)
                        {
                            indicate_data[i] = i % 0xff;
                        }
                        //the size of indicate_data[] need less than MTU size
                        esp_ble_gatts_send_indicate(gatts_if, param->write.conn_id, gl_profile_tab[PROFILE_A_APP_ID].char_handle,
                                                    sizeof(indicate_data), indicate_data, true);
                    }
                }
                else if (descr_value == 0x0000)
                {
                    ESP_LOGI(GATTS_TAG, "notify/indicate disable ");
                }
                else
                {
                    ESP_LOGE(GATTS_TAG, "unknown descr value");
                    esp_log_buffer_hex(GATTS_TAG, param->write.value, param->write.len);
                }
            }
        }
        example_write_event_env(gatts_if, &a_prepare_write_env, param);
        break;
    }
    case ESP_GATTS_EXEC_WRITE_EVT:
        ESP_LOGI(GATTS_TAG, "ESP_GATTS_EXEC_WRITE_EVT");
        esp_ble_gatts_send_response(gatts_if, param->write.conn_id, param->write.trans_id, ESP_GATT_OK, NULL);
        example_exec_write_event_env(&a_prepare_write_env, param);
        break;
    case ESP_GATTS_MTU_EVT:
        ESP_LOGI(GATTS_TAG, "ESP_GATTS_MTU_EVT, MTU %d", param->mtu.mtu);
        break;
    case ESP_GATTS_UNREG_EVT:
        break;
    case ESP_GATTS_CREATE_EVT:
        ESP_LOGI(GATTS_TAG, "CREATE_SERVICE_EVT, status %d,  service_handle %d\n", param->create.status, param->create.service_handle);
        gl_profile_tab[PROFILE_A_APP_ID].service_handle = param->create.service_handle;
        gl_profile_tab[PROFILE_A_APP_ID].char_uuid.len = ESP_UUID_LEN_16;
        gl_profile_tab[PROFILE_A_APP_ID].char_uuid.uuid.uuid16 = GATTS_CHAR_UUID_TEST_A;

        esp_ble_gatts_start_service(gl_profile_tab[PROFILE_A_APP_ID].service_handle);
        a_property = ESP_GATT_CHAR_PROP_BIT_READ | ESP_GATT_CHAR_PROP_BIT_WRITE | ESP_GATT_CHAR_PROP_BIT_NOTIFY;
        esp_err_t add_char_ret = esp_ble_gatts_add_char(gl_profile_tab[PROFILE_A_APP_ID].service_handle, &gl_profile_tab[PROFILE_A_APP_ID].char_uuid,
                                                        ESP_GATT_PERM_READ | ESP_GATT_PERM_WRITE,
                                                        a_property,
                                                        &gatts_demo_char1_val, NULL);
        if (add_char_ret)
        {
            ESP_LOGE(GATTS_TAG, "add char failed, error code =%x", add_char_ret);
        }
        break;
    case ESP_GATTS_ADD_INCL_SRVC_EVT:
        break;
    case ESP_GATTS_ADD_CHAR_EVT:
    {
        uint16_t length = 0;
        const uint8_t *prf_char;

        ESP_LOGI(GATTS_TAG, "ADD_CHAR_EVT, status %d,  attr_handle %d, service_handle %d\n",
                 param->add_char.status, param->add_char.attr_handle, param->add_char.service_handle);
        gl_profile_tab[PROFILE_A_APP_ID].char_handle = param->add_char.attr_handle;
        gl_profile_tab[PROFILE_A_APP_ID].descr_uuid.len = ESP_UUID_LEN_16;
        gl_profile_tab[PROFILE_A_APP_ID].descr_uuid.uuid.uuid16 = ESP_GATT_UUID_CHAR_CLIENT_CONFIG;
        esp_err_t get_attr_ret = esp_ble_gatts_get_attr_value(param->add_char.attr_handle, &length, &prf_char);
        if (get_attr_ret == ESP_FAIL)
        {
            ESP_LOGE(GATTS_TAG, "ILLEGAL HANDLE");
        }

        ESP_LOGI(GATTS_TAG, "the gatts demo char length = %x\n", length);
        for (int i = 0; i < length; i++)
        {
            ESP_LOGI(GATTS_TAG, "prf_char[%x] =%x\n", i, prf_char[i]);
        }
        esp_err_t add_descr_ret = esp_ble_gatts_add_char_descr(gl_profile_tab[PROFILE_A_APP_ID].service_handle, &gl_profile_tab[PROFILE_A_APP_ID].descr_uuid,
                                                               ESP_GATT_PERM_READ | ESP_GATT_PERM_WRITE, NULL, NULL);
        if (add_descr_ret)
        {
            ESP_LOGE(GATTS_TAG, "add char descr failed, error code =%x", add_descr_ret);
        }
        break;
    }
    case ESP_GATTS_ADD_CHAR_DESCR_EVT:
        gl_profile_tab[PROFILE_A_APP_ID].descr_handle = param->add_char_descr.attr_handle;
        ESP_LOGI(GATTS_TAG, "ADD_DESCR_EVT, status %d, attr_handle %d, service_handle %d\n",
                 param->add_char_descr.status, param->add_char_descr.attr_handle, param->add_char_descr.service_handle);
        break;
    case ESP_GATTS_DELETE_EVT:
        break;
    case ESP_GATTS_START_EVT:
        ESP_LOGI(GATTS_TAG, "SERVICE_START_EVT, status %d, service_handle %d\n",
                 param->start.status, param->start.service_handle);
        break;
    case ESP_GATTS_STOP_EVT:
        break;
    case ESP_GATTS_CONNECT_EVT:
    {
        esp_ble_conn_update_params_t conn_params = {0};
        memcpy(conn_params.bda, param->connect.remote_bda, sizeof(esp_bd_addr_t));
        /* For the IOS system, please reference the apple official documents about the ble connection parameters restrictions. */
        conn_params.latency = 0;
        conn_params.max_int = 0x20; // max_int = 0x20*1.25ms = 40ms
        conn_params.min_int = 0x10; // min_int = 0x10*1.25ms = 20ms
        conn_params.timeout = 400;  // timeout = 400*10ms = 4000ms
        ESP_LOGI(GATTS_TAG, "ESP_GATTS_CONNECT_EVT, conn_id %d, remote %02x:%02x:%02x:%02x:%02x:%02x:",
                 param->connect.conn_id,
                 param->connect.remote_bda[0], param->connect.remote_bda[1], param->connect.remote_bda[2],
                 param->connect.remote_bda[3], param->connect.remote_bda[4], param->connect.remote_bda[5]);
        gl_profile_tab[PROFILE_A_APP_ID].conn_id = param->connect.conn_id;
        //start sent the update connection parameters to the peer device.
        esp_ble_gap_update_conn_params(&conn_params);

        break;
    }
    case ESP_GATTS_DISCONNECT_EVT:
        ESP_LOGI(GATTS_TAG, "ESP_GATTS_DISCONNECT_EVT, disconnect reason 0x%x", param->disconnect.reason);
        esp_ble_gap_start_advertising(&adv_params);
        break;
    case ESP_GATTS_CONF_EVT:
        ESP_LOGI(GATTS_TAG, "ESP_GATTS_CONF_EVT, status %d attr_handle %d", param->conf.status, param->conf.handle);
        if (param->conf.status != ESP_GATT_OK)
        {
            esp_log_buffer_hex(GATTS_TAG, param->conf.value, param->conf.len);
        }
        break;
    case ESP_GATTS_OPEN_EVT:
    case ESP_GATTS_CANCEL_OPEN_EVT:
    case ESP_GATTS_CLOSE_EVT:
    case ESP_GATTS_LISTEN_EVT:
    case ESP_GATTS_CONGEST_EVT:
    default:
        break;
    }
}

static void gatts_profile_b_event_handler(esp_gatts_cb_event_t event, esp_gatt_if_t gatts_if, esp_ble_gatts_cb_param_t *param)
{
    switch (event)
    {
    case ESP_GATTS_REG_EVT:
        ESP_LOGI(GATTS_TAG, "REGISTER_APP_EVT, status %d, app_id %d\n", param->reg.status, param->reg.app_id);
        gl_profile_tab[PROFILE_B_APP_ID].service_id.is_primary = true;
        gl_profile_tab[PROFILE_B_APP_ID].service_id.id.inst_id = 0x00;
        gl_profile_tab[PROFILE_B_APP_ID].service_id.id.uuid.len = ESP_UUID_LEN_16;
        gl_profile_tab[PROFILE_B_APP_ID].service_id.id.uuid.uuid.uuid16 = GATTS_SERVICE_UUID_TEST_B;

        esp_ble_gatts_create_service(gatts_if, &gl_profile_tab[PROFILE_B_APP_ID].service_id, GATTS_NUM_HANDLE_TEST_B);
        break;
    case ESP_GATTS_READ_EVT:
    {
        nvs_handle_t my_handle;
        esp_err_t err;
        err = nvs_open(STORAGE_NAMESPACE, NVS_READWRITE, &my_handle);
        if (err != ESP_OK)
            return;

        // int32_t current_kural_number = get_i32_in_nvs(KEY_KURAL_NUMBER);
        int32_t button_press1 = get_i32_in_nvs(KEY_B1_PREV);
        int32_t button_press2 = get_i32_in_nvs(KEY_B2_NEXT);
        // int32_t button_press3 = get_i32_in_nvs(KEY_B3_FAV);
        // int32_t button_press4 = get_i32_in_nvs(KEY_B4_POWER);
        // int32_t button_press5 = get_i32_in_nvs(KEY_BLE_MODE);

        ESP_LOGI(GATTS_TAG, "GATT_READ_EVT, conn_id %d, trans_id %d, handle %d\n", param->read.conn_id, param->read.trans_id, param->read.handle);
        esp_gatt_rsp_t rsp;
        memset(&rsp, 0, sizeof(esp_gatt_rsp_t));

        rsp.attr_value.handle = param->read.handle;

        // rsp.attr_value.value[0] = current_kural_number;
        // rsp.attr_value.value[1] = button_press1;
        // rsp.attr_value.value[2] = button_press2;
        // rsp.attr_value.value[3] = button_press3;
        // rsp.attr_value.value[4] = button_press4;
        // rsp.attr_value.value[5] = button_press5;
        // rsp.attr_value.value[6] = 0;

        int shouldContinue = 1;
        int runj = 0;
        int read_offset = get_i32_in_nvs(KEY_READ_OFFSET);
        printf("READ OFFSET = %d", read_offset);
        int totalButtonPress = button_press1 + button_press2;
        for (int i = read_offset; i <= totalButtonPress; i++)
        {
            if (shouldContinue == 0)
            {
                break;
            }
            char read_log[500];
            size_t strlongth = malloc(200);
            char blank[200];
            sprintf(blank, "%d", i);
            err = nvs_get_str(my_handle, blank, read_log, &strlongth);
            if (err != ESP_OK && err != ESP_ERR_NVS_NOT_FOUND)
                return;

            char buffer[502];
            char *key = int_to_6_char_string(i);
            sprintf(buffer, "%s %s;", key, read_log);
            for (int j = 0; j < strlen(buffer); j++)
            {
                if (runj + j > 498)
                {
                    shouldContinue = 0;
                    break;
                }
                rsp.attr_value.len = runj + j;
                rsp.attr_value.value[runj + j] = buffer[j];
            }
            runj = runj + strlen(buffer);
        }

        esp_ble_gatts_send_response(gatts_if, param->read.conn_id, param->read.trans_id,
                                    ESP_GATT_OK, &rsp);
        nvs_close(my_handle);
        break;
    }
    case ESP_GATTS_WRITE_EVT:
    {
        ESP_LOGI(GATTS_TAG, "GATT_WRITE_EVT, conn_id %d, trans_id %d, handle %d\n", param->write.conn_id, param->write.trans_id, param->write.handle);
        if (!param->write.is_prep)
        {
            ESP_LOGI(GATTS_TAG, "GATT_WRITE_EVT, value len %d, value :", param->write.len);

            //Get Time from the Bluetooth Via Phone and set it as ESP device time

            char Buffer[48] = "";
            for (int ii = 0; ii < param->write.len; ii++)
            {
                printf("\n%x\n", param->write.value[ii]);
                sprintf(Buffer + strlen(Buffer), "%x", param->write.value[ii]);
                printf("\n%s\n", Buffer);

                //const char st[] = "30342d30322d32312031343a34333a3030";
                char st[100];
                for (int i = 0; i < strlen(Buffer); i++)
                {
                    if (Buffer[i] < '0' || Buffer[i] > '255')
                    {
                        // st[i] = Buffer[i];
                    }
                    else
                    {
                        st[i] = Buffer[i];
                    }
                }

                const char *src = st;
                char text[sizeof(st)];
                address = (char *)malloc((sizeof(st)) * sizeof(char));
                printf("op%s\n", text);
                printf("op%s\n", text);
                char *dst = text;
                while (*src != '\0')
                {
                    const unsigned char high = hexdigit2int(*src++);
                    const unsigned char low = hexdigit2int(*src++);
                    *dst++ = (high << 4) | low;
                }
                *dst-- = '\0';
                *dst-- = '\0';

                strcpy(address, text);
                if (ii == param->write.len - 1)
                {
                    printf("\nConverted '%s', got '%s'\n", st, text);
                }
            }

            esp_log_buffer_hex(GATTS_TAG, param->write.value, param->write.len);

            if (gl_profile_tab[PROFILE_B_APP_ID].descr_handle == param->write.handle && param->write.len == 2)
            {
                uint16_t descr_value = param->write.value[1] << 8 | param->write.value[0];
                if (descr_value == 0x0001)
                {
                    if (b_property & ESP_GATT_CHAR_PROP_BIT_NOTIFY)
                    {
                        ESP_LOGI(GATTS_TAG, "notify enable");
                        uint8_t notify_data[15];
                        for (int i = 0; i < sizeof(notify_data); ++i)
                        {
                            notify_data[i] = i % 0xff;
                        }
                        //the size of notify_data[] need less than MTU size
                        esp_ble_gatts_send_indicate(gatts_if, param->write.conn_id, gl_profile_tab[PROFILE_B_APP_ID].char_handle,
                                                    sizeof(notify_data), notify_data, false);
                    }
                }
                else if (descr_value == 0x0002)
                {
                    if (b_property & ESP_GATT_CHAR_PROP_BIT_INDICATE)
                    {
                        ESP_LOGI(GATTS_TAG, "indicate enable");
                        uint8_t indicate_data[15];
                        for (int i = 0; i < sizeof(indicate_data); ++i)
                        {
                            indicate_data[i] = i % 0xff;
                        }
                        //the size of indicate_data[] need less than MTU size
                        esp_ble_gatts_send_indicate(gatts_if, param->write.conn_id, gl_profile_tab[PROFILE_B_APP_ID].char_handle,
                                                    sizeof(indicate_data), indicate_data, true);
                    }
                }
                else if (descr_value == 0x0000)
                {
                    ESP_LOGI(GATTS_TAG, "notify/indicate disable ");
                }
                else
                {
                    ESP_LOGE(GATTS_TAG, "unknown value");
                }
            }

            setenv("TZ", "IST-5:30", 1);
            tzset();
            strptime(address, "%c", &tm);
            t = mktime(&tm);
            localtime_r(&t, &timeinfo);
            settimeofday(&t, NULL);
            strftime(strftime_buf, sizeof(strftime_buf), "%c", &timeinfo);
            ESP_LOGI(TAG2, "The current date/time in India is: %s", strftime_buf);
        }
        example_write_event_env(gatts_if, &b_prepare_write_env, param);

        fflush(stdout);
        esp_restart();
        break;
    }
    case ESP_GATTS_EXEC_WRITE_EVT:
        ESP_LOGI(GATTS_TAG, "ESP_GATTS_EXEC_WRITE_EVT");
        esp_ble_gatts_send_response(gatts_if, param->write.conn_id, param->write.trans_id, ESP_GATT_OK, NULL);
        example_exec_write_event_env(&b_prepare_write_env, param);
        break;
    case ESP_GATTS_MTU_EVT:
        ESP_LOGI(GATTS_TAG, "ESP_GATTS_MTU_EVT, MTU %d", param->mtu.mtu);
        break;
    case ESP_GATTS_UNREG_EVT:
        break;
    case ESP_GATTS_CREATE_EVT:
        ESP_LOGI(GATTS_TAG, "CREATE_SERVICE_EVT, status %d,  service_handle %d\n", param->create.status, param->create.service_handle);
        gl_profile_tab[PROFILE_B_APP_ID].service_handle = param->create.service_handle;
        gl_profile_tab[PROFILE_B_APP_ID].char_uuid.len = ESP_UUID_LEN_16;
        gl_profile_tab[PROFILE_B_APP_ID].char_uuid.uuid.uuid16 = GATTS_CHAR_UUID_TEST_B;

        esp_ble_gatts_start_service(gl_profile_tab[PROFILE_B_APP_ID].service_handle);
        b_property = ESP_GATT_CHAR_PROP_BIT_READ | ESP_GATT_CHAR_PROP_BIT_WRITE | ESP_GATT_CHAR_PROP_BIT_NOTIFY;
        esp_err_t add_char_ret = esp_ble_gatts_add_char(gl_profile_tab[PROFILE_B_APP_ID].service_handle, &gl_profile_tab[PROFILE_B_APP_ID].char_uuid,
                                                        ESP_GATT_PERM_READ | ESP_GATT_PERM_WRITE,
                                                        b_property,
                                                        NULL, NULL);
        if (add_char_ret)
        {
            ESP_LOGE(GATTS_TAG, "add char failed, error code =%x", add_char_ret);
        }
        break;
    case ESP_GATTS_ADD_INCL_SRVC_EVT:
        break;
    case ESP_GATTS_ADD_CHAR_EVT:
        ESP_LOGI(GATTS_TAG, "ADD_CHAR_EVT, status %d,  attr_handle %d, service_handle %d\n",
                 param->add_char.status, param->add_char.attr_handle, param->add_char.service_handle);

        gl_profile_tab[PROFILE_B_APP_ID].char_handle = param->add_char.attr_handle;
        gl_profile_tab[PROFILE_B_APP_ID].descr_uuid.len = ESP_UUID_LEN_16;
        gl_profile_tab[PROFILE_B_APP_ID].descr_uuid.uuid.uuid16 = ESP_GATT_UUID_CHAR_CLIENT_CONFIG;
        esp_ble_gatts_add_char_descr(gl_profile_tab[PROFILE_B_APP_ID].service_handle, &gl_profile_tab[PROFILE_B_APP_ID].descr_uuid,
                                     ESP_GATT_PERM_READ | ESP_GATT_PERM_WRITE,
                                     NULL, NULL);
        break;
    case ESP_GATTS_ADD_CHAR_DESCR_EVT:
        gl_profile_tab[PROFILE_B_APP_ID].descr_handle = param->add_char_descr.attr_handle;
        ESP_LOGI(GATTS_TAG, "ADD_DESCR_EVT, status %d, attr_handle %d, service_handle %d\n",
                 param->add_char_descr.status, param->add_char_descr.attr_handle, param->add_char_descr.service_handle);
        break;
    case ESP_GATTS_DELETE_EVT:
        break;
    case ESP_GATTS_START_EVT:
    {

        ESP_LOGI(GATTS_TAG, "SERVICE_START_EVT, status %d, service_handle %d\n",
                 param->start.status, param->start.service_handle);
    }

    break;
    case ESP_GATTS_STOP_EVT:
        break;
    case ESP_GATTS_CONNECT_EVT:

        gpio_pad_select_gpio(GPIO_NUM_33);
        // gpio_set_direction(GPIO_NUM_25, GPIO_MODE_DEF_OUTPUT);
        gpio_set_level(GPIO_NUM_33, 1);
        bleblink = 1;
        ESP_LOGI(GATTS_TAG, "CONNECT_EVT, conn_id %d, remote %02x:%02x:%02x:%02x:%02x:%02x:",
                 param->connect.conn_id,
                 param->connect.remote_bda[0], param->connect.remote_bda[1], param->connect.remote_bda[2],
                 param->connect.remote_bda[3], param->connect.remote_bda[4], param->connect.remote_bda[5]);
        gl_profile_tab[PROFILE_B_APP_ID].conn_id = param->connect.conn_id;
        break;
    case ESP_GATTS_CONF_EVT:
        ESP_LOGI(GATTS_TAG, "ESP_GATTS_CONF_EVT status %d attr_handle %d", param->conf.status, param->conf.handle);
        if (param->conf.status != ESP_GATT_OK)
        {
            esp_log_buffer_hex(GATTS_TAG, param->conf.value, param->conf.len);
        }
        break;
    case ESP_GATTS_DISCONNECT_EVT:
    {
        fflush(stdout);
        esp_restart();
        break;
    }
    case ESP_GATTS_OPEN_EVT:
    case ESP_GATTS_CANCEL_OPEN_EVT:
    case ESP_GATTS_CLOSE_EVT:
    case ESP_GATTS_LISTEN_EVT:
    case ESP_GATTS_CONGEST_EVT:
    default:
        break;
    }
}

static void gatts_event_handler(esp_gatts_cb_event_t event, esp_gatt_if_t gatts_if, esp_ble_gatts_cb_param_t *param)
{
    /* If event is register event, store the gatts_if for each profile */
    if (event == ESP_GATTS_REG_EVT)
    {
        if (param->reg.status == ESP_GATT_OK)
        {
            gl_profile_tab[param->reg.app_id].gatts_if = gatts_if;
        }
        else
        {
            ESP_LOGI(GATTS_TAG, "Reg app failed, app_id %04x, status %d\n",
                     param->reg.app_id,
                     param->reg.status);
            return;
        }
    }

    /* If the gatts_if equal to profile A, call profile A cb handler,
     * so here call each profile's callback */
    do
    {
        int idx;
        for (idx = 0; idx < PROFILE_NUM; idx++)
        {
            if (gatts_if == ESP_GATT_IF_NONE || /* ESP_GATT_IF_NONE, not specify a certain gatt_if, need to call every profile cb function */
                gatts_if == gl_profile_tab[idx].gatts_if)
            {
                if (gl_profile_tab[idx].gatts_cb)
                {
                    gl_profile_tab[idx].gatts_cb(event, gatts_if, param);
                }
            }
        }
    } while (0);
}

void start_ble()
{
    ESP_ERROR_CHECK(esp_bt_controller_mem_release(ESP_BT_MODE_CLASSIC_BT));

    esp_bt_controller_config_t bt_cfg = BT_CONTROLLER_INIT_CONFIG_DEFAULT();
    esp_err_t ret = esp_bt_controller_init(&bt_cfg);
    if (ret)
    {
        ESP_LOGE(GATTS_TAG, "%s initialize controller failed: %s\n", __func__, esp_err_to_name(ret));
        return;
    }

    ret = esp_bt_controller_enable(ESP_BT_MODE_BLE);
    if (ret)
    {
        ESP_LOGE(GATTS_TAG, "%s enable controller failed: %s\n", __func__, esp_err_to_name(ret));
        return;
    }
    ret = esp_bluedroid_init();
    if (ret)
    {
        ESP_LOGE(GATTS_TAG, "%s init bluetooth failed: %s\n", __func__, esp_err_to_name(ret));
        return;
    }
    ret = esp_bluedroid_enable();
    if (ret)
    {
        ESP_LOGE(GATTS_TAG, "%s enable bluetooth failed: %s\n", __func__, esp_err_to_name(ret));
        return;
    }

    ret = esp_ble_gatts_register_callback(gatts_event_handler);
    if (ret)
    {
        ESP_LOGE(GATTS_TAG, "gatts register error, error code = %x", ret);
        return;
    }
    ret = esp_ble_gap_register_callback(gap_event_handler);
    if (ret)
    {
        ESP_LOGE(GATTS_TAG, "gap register error, error code = %x", ret);
        return;
    }
    ret = esp_ble_gatts_app_register(PROFILE_A_APP_ID);
    if (ret)
    {
        ESP_LOGE(GATTS_TAG, "gatts app register error, error code = %x", ret);
        return;
    }
    ret = esp_ble_gatts_app_register(PROFILE_B_APP_ID);
    if (ret)
    {
        ESP_LOGE(GATTS_TAG, "gatts app register error, error code = %x", ret);
        return;
    }
    esp_err_t local_mtu_ret = esp_ble_gatt_set_local_mtu(500);
    if (local_mtu_ret)
    {
        ESP_LOGE(GATTS_TAG, "set local  MTU failed, error code = %x", local_mtu_ret);
    }
}

void app_main(void)
{
    esp_err_t err = nvs_flash_init();
    if (err == ESP_ERR_NVS_NO_FREE_PAGES || err == ESP_ERR_NVS_NEW_VERSION_FOUND)
    {
        // NVS partition was truncated and needs to be erased
        ESP_ERROR_CHECK(nvs_flash_erase());
        // Retry nvs_flash_init
        err = nvs_flash_init();
    }
    ESP_ERROR_CHECK(err);

    #if CONFIG_IDF_TARGET_ESP32
    //Check if Two Point or Vref are burned into eFuse
    check_efuse();
#endif

    //Configure ADC
    if (unit == ADC_UNIT_1) {
        adc1_config_width(ADC_WIDTH_BIT_12);
        adc1_config_channel_atten(channel, atten);
    } else {
        adc2_config_channel_atten((adc2_channel_t)channel, atten);
    }

#if CONFIG_IDF_TARGET_ESP32
    //Characterize ADC
    adc_chars = calloc(1, sizeof(esp_adc_cal_characteristics_t));
    esp_adc_cal_value_t val_type = esp_adc_cal_characterize(unit, atten, ADC_WIDTH_BIT_12, DEFAULT_VREF, adc_chars);
    print_char_val_type(val_type);
#endif

    //Once sample ADC1
    
        uint32_t adc_reading = 0;
        //Multisampling
        for (int i = 0; i < NO_OF_SAMPLES; i++) {
            if (unit == ADC_UNIT_1) {
                adc_reading += adc1_get_raw((adc1_channel_t)channel);
            } else {
                int raw;
                adc2_get_raw((adc2_channel_t)channel, ADC_WIDTH_BIT_12, &raw);
                adc_reading += raw;
            }
        }
        adc_reading /= NO_OF_SAMPLES;
#if CONFIG_IDF_TARGET_ESP32
        //Convert adc_reading to voltage in mV
        uint32_t voltage = esp_adc_cal_raw_to_voltage(adc_reading, adc_chars);
        printf("Raw: %d", adc_reading);
        // 4.2 V is max voltage from battery
        // 4.2 V is split into 3.1 & 1.1 V resp
        // 1.1 V is read into GPIO 34 because max volt given to any gpio is 3.3 & E-fuse is set to read reference of 1.1 V only
        // 4.2 V is split by using 64K Ohm & 24.1K Ohm 
        // 4200mV is battery voltage & 4096 is max adc units
        // 4200 / 4096 is 1.02539

        err = save_adc(adc_reading);                                                                        //  FOR BATTERY TESTING
                if (err != ESP_OK)                                                                          //  FOR BATTERY TESTING
                    printf("Error (%s) saving button press blob to NVS!\n", esp_err_to_name(err));          //  FOR BATTERY TESTING

        float final= (adc_reading *1.02539);
        final= final/1000;
        int percent= (adc_reading*100)/4095;
        printf("\tVOLTAGE: %f", (final));
        printf("\tPERCENTAGE: %d\n", percent);
        int bar=0;
        // if(100>= percent && percent>=76){
        //     bar=4;
        // } else if (75>=percent && percent>=51){
        //     bar=3;
        // } else if (50>=percent && percent>=26){
        //     bar=2;
        // } else {
        //     bar=1;
        // }

        bar=percent;

        // !!! THIS IS THE CODE FOR DISPLAYING LED WHEN CHARGING !!!
        // nvs_handle_t my_handle;
        // err = nvs_open("storage", NVS_READWRITE, &my_handle);

        // // Read
        // int32_t percent_conter = percent; // value will default to percent, if not set yet in NVS
        // err = nvs_get_i32(my_handle, "percent_counter", &percent_conter);
        
        // // Logic Check for Recharge/Discharge
        // if (percent > percent_conter){
        //     // xTaskCreate for LED BLINK
        // }
        // if (percent < percent_conter){
        //     // if xTaskCreate created 
        //     // then Delete
        // }

        // // Write
        // percent_conter=percent;
        // err = nvs_set_i32(my_handle, "percent_counter", percent_conter);
        // err = nvs_commit(my_handle);
        // nvs_close(my_handle);

#elif CONFIG_IDF_TARGET_ESP32S2BETA
        // printf("ADC%d CH%d Raw: %d\t", unit, channel, adc_reading);
        // printf("\tVOLTAGE: %d V\n", (adc_reading*2));
#endif
        vTaskDelay(pdMS_TO_TICKS(50));
    

    if (get_i32_in_nvs(KEY_KURAL_NUMBER) == 0)
    {
        set_i32_in_nvs(KEY_KURAL_NUMBER, 1);
        // xTaskCreate(&e_paper_task, "epaper_task", 4 * 1024, (void *)bar, 5, NULL);       //  FOR BATTERY TESTING WE SHOULD COMMENT THIS
    }

    int b1 = 0;
    int b2 = 0;

    gpio_pad_select_gpio(GPIO_NUM_33);
    gpio_set_direction(GPIO_NUM_33, GPIO_MODE_DEF_OUTPUT);
    gpio_set_level(GPIO_NUM_33, 0);
    // gpio_set_direction(GPIO_NUM_25, GPIO_MODE_DEF_OUTPUT);
    // gpio_pad_select_gpio(GPIO_NUM_25);
    // gpio_set_level(GPIO_NUM_25, 1);
    // i2c_master_init();

    bleblink = 0;

    gpio_pad_select_gpio(GPIO_NUM_0);
    gpio_set_direction(GPIO_NUM_0, GPIO_MODE_DEF_INPUT);
    gpio_pad_select_gpio(GPIO_NUM_26);
    gpio_set_direction(GPIO_NUM_26, GPIO_MODE_DEF_INPUT);
    gpio_pad_select_gpio(GPIO_NUM_13);
    gpio_set_direction(GPIO_NUM_13, GPIO_MODE_DEF_INPUT);
    gpio_pad_select_gpio(GPIO_NUM_14);
    gpio_set_direction(GPIO_NUM_14, GPIO_MODE_DEF_INPUT);
    gpio_pad_select_gpio(GPIO_NUM_2);
    gpio_set_direction(GPIO_NUM_2, GPIO_MODE_DEF_INPUT);

    struct timeval now;
    gettimeofday(&now, NULL);
    int sleep_time_ms = (now.tv_sec - sleep_enter_time.tv_sec) * 1000 + (now.tv_usec - sleep_enter_time.tv_usec) / 1000;

    setenv("TZ", "IST-5:30", 1);
    tzset();
    time(&t);
    localtime_r(&t, &timeinfo);
    printf("1st%d\n", timeinfo.tm_year);
    if (timeinfo.tm_year < (1970 - 1900))
    {
        ESP_LOGI(TAG2, "Time is not set yet. Connecting to WiFi and getting time over NTP.");
    }
    int pin = 100;
    switch (esp_sleep_get_wakeup_cause())
    {
    case ESP_SLEEP_WAKEUP_EXT1:
    {
        uint64_t wakeup_pin_mask = esp_sleep_get_ext1_wakeup_status();
        if (wakeup_pin_mask != 0)
        {
            pin = __builtin_ffsll(wakeup_pin_mask) - 1;
            printf("Wake up from GPIO %d\n", pin);
            err = increment_nvs_value(KEY_B4_POWER);
            if (err != ESP_OK)
                printf("Error (%s) saving button press blob to NVS!\n", esp_err_to_name(err));
        }
        else
        {
            printf("Wake up from GPIO\n");
            err = increment_nvs_value(KEY_B4_POWER);
            if (err != ESP_OK)
                printf("Error (%s) saving button press blob to NVS!\n", esp_err_to_name(err));
        }
        break;
    }
    case ESP_SLEEP_WAKEUP_TIMER:
    {
        printf("Wake up from timer. Time spent in deep sleep: %dms\n", sleep_time_ms);
        break;
    }
    case ESP_SLEEP_WAKEUP_UNDEFINED:
    default:
        printf("Welcome\n");
    }


    const int ext_wakeup_pin_1 = 26;
    const uint64_t ext_wakeup_pin_1_mask = 1ULL << ext_wakeup_pin_1;
    const int ext_wakeup_pin_2 = 13;
    const uint64_t ext_wakeup_pin_2_mask = 1ULL << ext_wakeup_pin_2;
    const int ext_wakeup_pin_3 = 14;
    const uint64_t ext_wakeup_pin_3_mask = 1ULL << ext_wakeup_pin_3;
    const int ext_wakeup_pin_4 = 2;
    const uint64_t ext_wakeup_pin_4_mask = 1ULL << ext_wakeup_pin_4;
    // const int ext_wakeup_pin_2 = 4;
    // const uint64_t ext_wakeup_pin_2_mask = 1ULL << ext_wakeup_pin_2;
    printf("Enabling EXT1 wakeup on pins GPIO%d, GPIO%d, GPIO%d & GPIO%d\n", ext_wakeup_pin_1, ext_wakeup_pin_2, ext_wakeup_pin_3, ext_wakeup_pin_4);
    esp_sleep_enable_ext1_wakeup(ext_wakeup_pin_1_mask | ext_wakeup_pin_2_mask | ext_wakeup_pin_3_mask | ext_wakeup_pin_4_mask, ESP_EXT1_WAKEUP_ANY_HIGH);

#if CONFIG_IDF_TARGET_ESP32
    // Isolate GPIO12 pin from external circuits. This is needed for modules
    // which have an external pull-up resistor on GPIO12 (such as ESP32-WROVER)
    // to minimize current consumption.
    rtc_gpio_isolate(GPIO_NUM_12);
    
#endif

    ESP_LOGI(TAG, "\nStarted timer, time since start: %lld us\n", esp_timer_get_time());

    long pipo = esp_timer_get_time();
    long end_cond = esp_timer_get_time();

#if CONFIG_ENABLE_DEBUG_MODE
    start_ble();
    return;
#endif

     b2++;

                err = save_button_press2();
                if (err != ESP_OK)
                    printf("Error (%s) saving button press blob to NVS!\n", esp_err_to_name(err));

                xTaskCreate(&e_paper_task, "epaper_task", 4 * 1024, (void *)bar, 5, NULL);

    while (1)
    {
        end_cond = esp_timer_get_time();
        if (end_cond > (pipo + 2000000))
        {
            // bar=bar+1000;
            // xTaskCreate(&e_paper_task, "epaper_task", 4 * 1024, (void *)bar, 5, NULL);
            // vTaskDelay(100 / portTICK_PERIOD_MS);
            err = save_restart_counter();                                                                       //  FOR BATTERY TESTING
            if (err != ESP_OK) printf("Error (%s) saving restart counter to NVS!\n", esp_err_to_name(err));     //  FOR BATTERY TESTING
            vTaskDelay(200 / portTICK_PERIOD_MS);                                                               //  FOR BATTERY TESTING
            break;
        }

        if (gpio_get_level(GPIO_NUM_26) != 0 || pin==26)
        {
            vTaskDelay(200 / portTICK_PERIOD_MS);
            if (gpio_get_level(GPIO_NUM_26) == 0 || pin==26)
            {
                b1++;

                err = save_button_press1();
                if (err != ESP_OK)
                    printf("Error (%s) saving button press blob to NVS!\n", esp_err_to_name(err));

                xTaskCreate(&e_paper_task, "epaper_task", 4 * 1024, (void *)bar, 5, NULL);
                // vTaskDelay(2500 / portTICK_PERIOD_MS);
                // xTaskCreate(&e_paper_taskpartial, "epaper_taskpartial", 4 * 1024, (void *)bar, 5, NULL);
                // vTaskDelay(1000 / portTICK_PERIOD_MS);

                ESP_LOGI(TAG, "\nStarted timer, time since start: %lld us\n", esp_timer_get_time());
                pipo = esp_timer_get_time();
                pin=100;
            }
        }
        if (gpio_get_level(GPIO_NUM_13) != 0 || pin==13)
        {
            vTaskDelay(200 / portTICK_PERIOD_MS);
            if (gpio_get_level(GPIO_NUM_13) == 0 || pin==13)
            {
                b2++;

                err = save_button_press2();
                if (err != ESP_OK)
                    printf("Error (%s) saving button press blob to NVS!\n", esp_err_to_name(err));

                xTaskCreate(&e_paper_task, "epaper_task", 4 * 1024, (void *)bar, 5, NULL);
                // vTaskDelay(2500 / portTICK_PERIOD_MS);
                // xTaskCreate(&e_paper_taskpartial, "epaper_taskpartial", 4 * 1024, (void *)bar, 5, NULL);
                // vTaskDelay(1000 / portTICK_PERIOD_MS);

                ESP_LOGI(TAG, "\nStarted timer, time since start: %lld us\n", esp_timer_get_time());
                pipo = esp_timer_get_time();
                pin=100;
            }
        }
        if (gpio_get_level(GPIO_NUM_2) != 0)
        {
            vTaskDelay(200 / portTICK_PERIOD_MS);
            if (gpio_get_level(GPIO_NUM_2) == 0)
            {
                err = increment_nvs_value(KEY_B4_POWER);
                if (err != ESP_OK){
                    printf("Error (%s) saving button press blob to NVS!\n", esp_err_to_name(err));
                }
                bar=bar+1000;
                xTaskCreate(&e_paper_task, "epaper_task", 4 * 1024, (void *)bar, 5, NULL);
                // vTaskDelay(200 / portTICK_PERIOD_MS);
                break;
            }
        }
        if (gpio_get_level(GPIO_NUM_2) != 0)
        {
            vTaskDelay(900 / portTICK_PERIOD_MS);
            if (gpio_get_level(GPIO_NUM_2) != 0)
            {
                err = increment_nvs_value(KEY_BLE_MODE);
                if (err != ESP_OK)
                    printf("Error (%s) saving button press blob to NVS!\n", esp_err_to_name(err));

                start_ble();

                long blestart = esp_timer_get_time();
                gpio_pad_select_gpio(GPIO_NUM_33);
                gpio_set_direction(GPIO_NUM_33, GPIO_MODE_DEF_OUTPUT);
                int enter_flag=0;
                while (1)
                {   
                    long blestop = esp_timer_get_time();
                    if (bleblink == 0)
                    {
                        if (blestop - blestart < 1000000)
                        {
                            gpio_set_level(GPIO_NUM_33, 1);
                        }
                        if (blestop - blestart > 1000000)
                        {
                            gpio_set_level(GPIO_NUM_33, 0);
                        }
                        if (blestop - blestart > 2000000)
                        {
                            blestart = esp_timer_get_time();
                        }
                    }
                    if (gpio_get_level(GPIO_NUM_2) == 0 && enter_flag==0)
                    {   
                        enter_flag=1;
                    }
                    if (gpio_get_level(GPIO_NUM_2) != 0 && enter_flag==1)
                    {
                        vTaskDelay(200 / portTICK_PERIOD_MS);
                        if (gpio_get_level(GPIO_NUM_2) == 0)
                        {
                            break;
                        }
                    }
                    vTaskDelay(50 / portTICK_PERIOD_MS);
                }
                break;
            }
        }
        if (gpio_get_level(GPIO_NUM_14) != 0 || pin==14)
        {
            vTaskDelay(200 / portTICK_PERIOD_MS);
            if (gpio_get_level(GPIO_NUM_14) == 0 || pin==14)
            {
                save_fav();
                xTaskCreate(&e_paper_task, "epaper_task", 4 * 1024, (void *)bar, 5, NULL);

                ESP_LOGI(TAG, "\nStarted timer, time since start: %lld us", esp_timer_get_time());
                pipo = esp_timer_get_time();
                pin=100;
            }
        }
    }
    
    strftime(strftime_buf, sizeof(strftime_buf), "%c", &timeinfo);
    ESP_LOGI(TAG2, "The current date/time in India is: %s", strftime_buf);
    // vTaskDelay(2500 / portTICK_PERIOD_MS);
    const int wakeup_time_sec = 4;                                          // FOR BATTERY TESTING
    printf("Enabling timer wakeup, %ds\n", wakeup_time_sec);                // FOR BATTERY TESTING
    esp_sleep_enable_timer_wakeup(wakeup_time_sec * 1000000);               // FOR BATTERY TESTING
    printf("\nEntering deep sleep\n\n\n");
    gettimeofday(&sleep_enter_time, NULL);
    esp_deep_sleep_start();
}
